name: üöÄ CI/CD Pipeline (GHCR)

on:
  push:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  EC2_INSTANCE_TAG: dive-inspector-server
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # =============================================================================
  # CI: BUILD, TEST, AND PUSH IMAGES
  # =============================================================================
  ci:
    name: üî® Build, Test & Push
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      packages: write
    
    outputs:
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
      backend-image: ${{ steps.meta.outputs.backend-tag }}
      frontend-image: ${{ steps.meta.outputs.frontend-tag }}
      
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîç Detect changes
      id: changes
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
        else
          echo "should-deploy=false" >> $GITHUB_OUTPUT
        fi
        
    - name: üê≥ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          image=moby/buildkit:buildx-stable-1
          
    - name: üîê Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: üìù Extract metadata
      id: meta
      run: |
        # Convert repository name to lowercase for GHCR compatibility
        REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
        echo "backend-tag=${{ env.REGISTRY }}/${REPO_LOWER}/dive-inspector-backend:${{ github.run_number }}" >> $GITHUB_OUTPUT
        echo "frontend-tag=${{ env.REGISTRY }}/${REPO_LOWER}/dive-inspector-frontend:${{ github.run_number }}" >> $GITHUB_OUTPUT
        echo "backend-cache=${{ env.REGISTRY }}/${REPO_LOWER}/dive-inspector-backend:cache" >> $GITHUB_OUTPUT
        echo "frontend-cache=${{ env.REGISTRY }}/${REPO_LOWER}/dive-inspector-frontend:cache" >> $GITHUB_OUTPUT
        
    - name: üèóÔ∏è Build and push backend
      env:
        BACKEND_IMAGE: ${{ steps.meta.outputs.backend-tag }}
        BACKEND_CACHE: ${{ steps.meta.outputs.backend-cache }}
      run: |
        cd backend
        
        # Build with registry cache
        docker buildx build \
          --platform linux/amd64 \
          --cache-from type=registry,ref=$BACKEND_CACHE \
          --cache-to type=registry,ref=$BACKEND_CACHE,mode=max \
          --tag $BACKEND_IMAGE \
          --tag ${{ env.REGISTRY }}/${{ github.repository_owner }}/dive-inspector-backend:latest \
          --push . || \
        docker buildx build \
          --platform linux/amd64 \
          --tag $BACKEND_IMAGE \
          --tag ${{ env.REGISTRY }}/${{ github.repository_owner }}/dive-inspector-backend:latest \
          --push .
        
    - name: üèóÔ∏è Build and push frontend
      env:
        FRONTEND_IMAGE: ${{ steps.meta.outputs.frontend-tag }}
        FRONTEND_CACHE: ${{ steps.meta.outputs.frontend-cache }}
      run: |
        cd frontend
        
        # Build with registry cache
        docker buildx build \
          --platform linux/amd64 \
          --cache-from type=registry,ref=$FRONTEND_CACHE \
          --cache-to type=registry,ref=$FRONTEND_CACHE,mode=max \
          --tag $FRONTEND_IMAGE \
          --tag ${{ env.REGISTRY }}/${{ github.repository_owner }}/dive-inspector-frontend:latest \
          --file Dockerfile.prod \
          --push . || \
        docker buildx build \
          --platform linux/amd64 \
          --tag $FRONTEND_IMAGE \
          --tag ${{ env.REGISTRY }}/${{ github.repository_owner }}/dive-inspector-frontend:latest \
          --file Dockerfile.prod \
          --push .
        
    - name: üß™ Run backend tests
      run: |
        docker run --rm \
          -v /var/run/docker.sock:/var/run/docker.sock \
          ${{ steps.meta.outputs.backend-tag }} \
          npm test
          
    - name: üìä Build performance report
      run: |
        echo "## üöÄ Build Performance" >> $GITHUB_STEP_SUMMARY
        echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Build Method | Docker Buildx + Layer Cache |" >> $GITHUB_STEP_SUMMARY
        echo "| Layer Caching | ‚úÖ Registry Cache |" >> $GITHUB_STEP_SUMMARY
        echo "| üì¶ Registry | GitHub Container Registry |" >> $GITHUB_STEP_SUMMARY
        echo "| Build Number | ${{ github.run_number }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Backend Image | \`${{ steps.meta.outputs.backend-tag }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| Frontend Image | \`${{ steps.meta.outputs.frontend-tag }}\` |" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # CD: DEPLOY TO EC2
  # =============================================================================
  cd:
    name: üöÄ Deploy to EC2
    runs-on: ubuntu-latest
    needs: ci
    if: needs.ci.outputs.should-deploy == 'true'
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_CICD_GITHUB_ACTIONS_USERID }}
        aws-secret-access-key: ${{ secrets.AWS_CICD_GITHUB_ACTIONS_ACCESSKEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üîç Get EC2 instance ID
      id: instance
      run: |
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${{ env.EC2_INSTANCE_TAG }}" \
                    "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].InstanceId" \
          --output text)
        
        if [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ]; then
          echo "‚ùå No running EC2 instance found with tag: ${{ env.EC2_INSTANCE_TAG }}"
          exit 1
        fi
        
        echo "instance-id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "‚úÖ Found EC2 instance: $INSTANCE_ID"
        
    - name: üöÄ Deploy via SSM
      run: |
        echo "üöÄ Executing deployment on EC2 instance..."
        
        # Variables for deployment
        GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
        GITHUB_USER="${{ github.actor }}"
        BACKEND_IMAGE="${{ needs.ci.outputs.backend-image }}"
        FRONTEND_IMAGE="${{ needs.ci.outputs.frontend-image }}"
        
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ steps.instance.outputs.instance-id }}" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[
            \"set -e\",
            \"echo \\\"üöÄ Starting GHCR deployment on \$(date)\\\"\", 
            \"cd /opt/dive-inspector\",
            \"CURRENT_COMMIT=\$(git rev-parse HEAD)\",
            \"echo \\\"üìù Current commit: \$CURRENT_COMMIT\\\"\",
            \"git fetch origin\",
            \"git reset --hard origin/main\", 
            \"NEW_COMMIT=\$(git rev-parse HEAD)\",
            \"echo \\\"üìù New commit: \$NEW_COMMIT\\\"\",
            \"if [ \\\"\$CURRENT_COMMIT\\\" = \\\"\$NEW_COMMIT\\\" ]; then echo \\\"‚ÑπÔ∏è No changes detected\\\"; exit 0; fi\",
            \"echo \\\"üîë Logging into GitHub Container Registry...\\\"\",
            \"echo $GITHUB_TOKEN | docker login ghcr.io -u $GITHUB_USER --password-stdin\",
            \"echo \\\"üìù Updating image tags...\\\"\",
            \"sed -i \\\"s|dive-inspector-backend:latest|$BACKEND_IMAGE|g\\\" docker-compose.yml\",
            \"sed -i \\\"s|dive-inspector-frontend:latest|$FRONTEND_IMAGE|g\\\" docker-compose.yml\",
            \"echo \\\"üè• Health check...\\\"\",
            \"curl -f http://localhost:3000/api/health || echo \\\"‚ö†Ô∏è Service unhealthy\\\"\",
            \"echo \\\"üì¶ Pulling images...\\\"\", 
            \"docker compose pull\",
            \"echo \\\"üîÑ Restarting...\\\"\",
            \"docker compose up -d\",
            \"sleep 10\",
            \"echo \\\"üè• Post-deployment check...\\\"\",
            \"for i in {1..30}; do if curl -f http://localhost:3000/api/health >/dev/null 2>&1; then echo \\\"‚úÖ Healthy!\\\"; break; fi; sleep 2; done\",
            \"echo \\\"üéâ GHCR deployment complete!\\\"\",
            \"docker compose ps\"
          ]" \
          --output text \
          --query "Command.CommandId")
        
        echo "‚úÖ Deployment command sent: $COMMAND_ID"
        
        # Wait for command completion
        echo "‚è≥ Waiting for deployment to complete..."
        
        for i in {1..60}; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.instance.outputs.instance-id }}" \
            --query "Status" \
            --output text 2>/dev/null || echo "InProgress")
            
          echo "üìä Status: $STATUS"
          
          if [ "$STATUS" = "Success" ]; then
            echo "‚úÖ Deployment completed successfully!"
            break
          elif [ "$STATUS" = "Failed" ]; then
            echo "‚ùå Deployment failed!"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ steps.instance.outputs.instance-id }}" \
              --query "StandardErrorContent" \
              --output text
            exit 1
          elif [ $i -eq 60 ]; then
            echo "‚ùå Deployment timed out after 10 minutes"
            exit 1
          fi
          
          sleep 10
        done
        
        # Get deployment output
        echo "üìã Deployment output:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ steps.instance.outputs.instance-id }}" \
          --query "StandardOutputContent" \
          --output text
          
    - name: üìä Deployment summary
      run: |
        echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| üì¶ Registry | GitHub Container Registry |" >> $GITHUB_STEP_SUMMARY
        echo "| üèóÔ∏è Backend | \`${{ needs.ci.outputs.backend-image }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| üé® Frontend | \`${{ needs.ci.outputs.frontend-image }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| üéØ Target | EC2 (${{ steps.instance.outputs.instance-id }}) |" >> $GITHUB_STEP_SUMMARY
        echo "| üìÖ Deployed | $(date -u '+%Y-%m-%d %H:%M:%S') UTC |" >> $GITHUB_STEP_SUMMARY
