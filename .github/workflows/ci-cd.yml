name: ðŸš€ CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  EC2_INSTANCE_TAG: dive-inspector-server

jobs:
  # =============================================================================
  # CI: BUILD, TEST, AND PUSH IMAGES
  # =============================================================================
  ci:
    name: ðŸ”¨ Build, Test & Push
    runs-on: ubuntu-latest
    
    outputs:
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
      backend-image: ${{ steps.meta.outputs.backend-tag }}
      frontend-image: ${{ steps.meta.outputs.frontend-tag }}
      
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
      
    - name: ðŸ” Detect changes
      id: changes
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
        else
          echo "should-deploy=false" >> $GITHUB_OUTPUT
        fi
        
    - name: ðŸ³ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: ðŸ”‘ Login to GitHub Container Registry
      if: steps.changes.outputs.should-deploy == 'true'
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: ðŸ“ Extract metadata
      id: meta
      run: |
        echo "backend-tag=ghcr.io/${{ github.repository_owner }}/dive-inspector-backend:${{ github.sha }}" >> $GITHUB_OUTPUT
        echo "frontend-tag=ghcr.io/${{ github.repository_owner }}/dive-inspector-frontend:${{ github.sha }}" >> $GITHUB_OUTPUT
        
    - name: ðŸ’¾ Cache backend npm dependencies
      uses: actions/cache@v4
      with:
        path: backend/node_modules
        key: ${{ runner.os }}-backend-npm-${{ hashFiles('backend/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-backend-npm-
          
    - name: ðŸ’¾ Cache frontend npm dependencies
      uses: actions/cache@v4
      with:
        path: frontend/node_modules
        key: ${{ runner.os }}-frontend-npm-${{ hashFiles('frontend/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-frontend-npm-
          
    - name: ðŸ—ï¸ Build and push backend
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: ${{ steps.changes.outputs.should-deploy == 'true' }}
        tags: ${{ steps.meta.outputs.backend-tag }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: ðŸ—ï¸ Build and push frontend
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile.prod
        push: ${{ steps.changes.outputs.should-deploy == 'true' }}
        tags: ${{ steps.meta.outputs.frontend-tag }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: ðŸ§ª Run backend tests
      run: |
        docker run --rm \
          -v /var/run/docker.sock:/var/run/docker.sock \
          ${{ steps.meta.outputs.backend-tag }} \
          npm test
          
    - name: ðŸ“Š Build performance report
      run: |
        echo "## ðŸš€ Build Performance" >> $GITHUB_STEP_SUMMARY
        echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Build Method | Docker Buildx + GitHub Cache |" >> $GITHUB_STEP_SUMMARY
        echo "| NPM Cache | âœ… Enabled |" >> $GITHUB_STEP_SUMMARY
        echo "| Docker Cache | âœ… GitHub Actions Cache |" >> $GITHUB_STEP_SUMMARY
        echo "| Registry | GitHub Container Registry |" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # CD: DEPLOY TO EC2
  # =============================================================================
  cd:
    name: ðŸš€ Deploy to EC2
    runs-on: ubuntu-latest
    needs: ci
    if: needs.ci.outputs.should-deploy == 'true'
    
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
      
    - name: ðŸ”§ Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_CICD_GITHUB_ACTIONS_USERID }}
        aws-secret-access-key: ${{ secrets.AWS_CICD_GITHUB_ACTIONS_ACCESSKEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: ðŸ” Get EC2 instance ID
      id: instance
      run: |
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${{ env.EC2_INSTANCE_TAG }}" \
                    "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].InstanceId" \
          --output text)
        
        if [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ]; then
          echo "âŒ No running EC2 instance found with tag: ${{ env.EC2_INSTANCE_TAG }}"
          exit 1
        fi
        
        echo "instance-id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "âœ… Found EC2 instance: $INSTANCE_ID"
        
    - name: ï¿½ Deploy via SSM
      run: |
        echo "ðŸš€ Executing deployment on EC2 instance..."
        
        aws ssm send-command \
          --instance-ids "${{ steps.instance.outputs.instance-id }}" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["
            set -e
            echo \"ðŸš€ Starting deployment on \$(date)\"
            
            # Navigate to application directory
            cd /opt/dive-inspector
            
            # Store current commit for rollback
            CURRENT_COMMIT=\$(git rev-parse HEAD)
            echo \"ðŸ“ Current commit: \$CURRENT_COMMIT\"
            
            # Pull latest changes
            echo \"ðŸ“¥ Pulling latest code...\"
            git fetch origin
            git reset --hard origin/main
            
            NEW_COMMIT=\$(git rev-parse HEAD)
            echo \"ðŸ“ New commit: \$NEW_COMMIT\"
            
            # Check if there are actually changes
            if [ \"\$CURRENT_COMMIT\" = \"\$NEW_COMMIT\" ]; then
              echo \"â„¹ï¸ No changes detected, skipping deployment\"
              exit 0
            fi
            
            # Login to GitHub Container Registry
            echo \"ðŸ”‘ Logging into GitHub Container Registry...\"
            echo \${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u \${{ github.actor }} --password-stdin
            
            # Update docker-compose.yml with new image tags
            echo \"ðŸ“ Updating image tags...\"
            sed -i 's|image: dive-inspector-backend:latest|image: ${{ needs.ci.outputs.backend-image }}|g' docker-compose.yml
            sed -i 's|image: dive-inspector-frontend:latest|image: ${{ needs.ci.outputs.frontend-image }}|g' docker-compose.yml
            
            # Health check before restart
            echo \"ðŸ¥ Running pre-deployment health check...\"
            curl -f http://localhost:3000/api/health || echo \"âš ï¸ Service currently unhealthy\"
            
            # Pull new images and restart services
            echo \"ðŸ“¦ Pulling new images...\"
            docker compose pull
            
            echo \"ðŸ”„ Restarting services...\"
            docker compose up -d
            
            # Wait for services to be ready
            echo \"â³ Waiting for services to start...\"
            sleep 10
            
            # Post-deployment health check
            echo \"ðŸ¥ Post-deployment health check...\"
            for i in {1..30}; do
              if curl -f http://localhost:3000/api/health > /dev/null 2>&1; then
                echo \"âœ… Health check passed!\"
                break
              fi
              if [ \$i -eq 30 ]; then
                echo \"âŒ Health check failed after 30 attempts\"
                echo \"ðŸ”„ Rolling back to previous commit...\"
                git reset --hard \$CURRENT_COMMIT
                docker compose pull
                docker compose up -d
                exit 1
              fi
              echo \"â³ Attempt \$i/30 - waiting for service...\"
              sleep 2
            done
            
            echo \"ðŸŽ‰ Deployment completed successfully!\"
            echo \"ðŸ“Š Service status:\"
            docker compose ps
            
            # Cleanup old images
            echo \"ðŸ§¹ Cleaning up old images...\"
            docker image prune -f
          "]' \
          --output text \
          --query "Command.CommandId"
            sudo git reset --hard $CURRENT_COMMIT
            sudo -E docker buildx bake
            sudo docker-compose up -d
            exit 1
          fi
          echo "â³ Attempt $i/30 - waiting for service..."
          sleep 2
        done
        
        echo "ðŸŽ‰ Deployment completed successfully!"
        echo "ðŸ“Š Service status:"
        sudo docker-compose ps
        EOF
        
        chmod +x deploy.sh
        
    - name: ðŸš€ Deploy via SSM
      run: |
        echo "ðŸš€ Executing deployment on EC2 instance..."
        
        # Send deployment script to EC2
        aws ssm send-command \
          --instance-ids "${{ steps.instance.outputs.instance-id }}" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["
            cd /tmp
            rm -f deploy.sh
            cat > deploy.sh << '\''EOF'\''
            #!/bin/bash
            set -e
            
            echo \"ðŸš€ Starting deployment on \$(date)\"
            
            # Navigate to application directory
            cd /opt/dive-inspector
            
            # Store current commit for rollback
            CURRENT_COMMIT=\$(git rev-parse HEAD)
            echo \"ðŸ“ Current commit: \$CURRENT_COMMIT\"
            
            # Pull latest changes
            echo \"ðŸ“¥ Pulling latest code...\"
            sudo git fetch origin
            sudo git reset --hard origin/main
            
            NEW_COMMIT=\$(git rev-parse HEAD)
            echo \"ðŸ“ New commit: \$NEW_COMMIT\"
            
            # Check if there are actually changes
            if [ \"\$CURRENT_COMMIT\" = \"\$NEW_COMMIT\" ]; then
              echo \"â„¹ï¸ No changes detected, skipping deployment\"
              exit 0
            fi
            
            # Build with optimized method
            echo \"ðŸ—ï¸ Building with optimized Docker...\"
            sudo -E docker buildx bake
            
            # Health check before restart
            echo \"ðŸ¥ Running pre-deployment health check...\"
            curl -f http://localhost:3000/api/health || echo \"âš ï¸ Service currently unhealthy\"
            
            # Restart services
            echo \"ðŸ”„ Restarting services...\"
            sudo docker-compose up -d
            
            # Wait for services to be ready
            echo \"â³ Waiting for services to start...\"
            sleep 10
            
            # Post-deployment health check
            echo \"ðŸ¥ Post-deployment health check...\"
            for i in {1..30}; do
              if curl -f http://localhost:3000/api/health > /dev/null 2>&1; then
                echo \"âœ… Health check passed!\"
                break
              fi
              if [ \$i -eq 30 ]; then
                echo \"âŒ Health check failed after 30 attempts\"
                echo \"ðŸ”„ Rolling back to previous commit...\"
                sudo git reset --hard \$CURRENT_COMMIT
                sudo -E docker buildx bake
                sudo docker-compose up -d
                exit 1
              fi
              echo \"â³ Attempt \$i/30 - waiting for service...\"
              sleep 2
            done
            
            echo \"ðŸŽ‰ Deployment completed successfully!\"
            echo \"ðŸ“Š Service status:\"
            sudo docker-compose ps
            EOF
            chmod +x deploy.sh
            ./deploy.sh
          "]' \
          --output text \
          --query "Command.CommandId" > command_id.txt
          
        COMMAND_ID=$(cat command_id.txt)
        echo "ðŸ“ Command ID: $COMMAND_ID"
        
        # Wait for command completion
        echo "â³ Waiting for deployment to complete..."
        
        for i in {1..60}; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.instance.outputs.instance-id }}" \
            --query "Status" \
            --output text 2>/dev/null || echo "InProgress")
            
          echo "ðŸ“Š Status: $STATUS"
          
          if [ "$STATUS" = "Success" ]; then
            echo "âœ… Deployment completed successfully!"
            break
          elif [ "$STATUS" = "Failed" ]; then
            echo "âŒ Deployment failed!"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ steps.instance.outputs.instance-id }}" \
              --query "StandardErrorContent" \
              --output text
            exit 1
          elif [ $i -eq 60 ]; then
            echo "âŒ Deployment timed out after 10 minutes"
            exit 1
          fi
          
          sleep 10
        done
        
        # Get deployment output
        echo "ðŸ“‹ Deployment output:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ steps.instance.outputs.instance-id }}" \
          --query "StandardOutputContent" \
          --output text
          
    - name: ðŸ¥ Final health check
      run: |
        # Get EC2 public IP for health check
        PUBLIC_IP=$(aws ec2 describe-instances \
          --instance-ids "${{ steps.instance.outputs.instance-id }}" \
          --query "Reservations[0].Instances[0].PublicIpAddress" \
          --output text)
          
        echo "ðŸ” Final health check against public endpoint..."
        
        # Note: This will hit Cloudflare, so it tests the full stack
        if curl -f -k "https://dive.docker-senpai.dev/api/health" > /dev/null 2>&1; then
          echo "âœ… Production health check passed!"
        else
          echo "âš ï¸ Production health check failed (might be DNS propagation)"
        fi
        
    - name: ðŸ“Š Deployment summary
      run: |
        echo "## ðŸŽ‰ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Item | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| ðŸ—ï¸ Build | âœ… Success |" >> $GITHUB_STEP_SUMMARY
        echo "| ðŸ§ª Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
        echo "| ðŸš€ Deployment | âœ… Success |" >> $GITHUB_STEP_SUMMARY
        echo "| ðŸ¥ Health Check | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
        echo "| â±ï¸ Build Method | Docker Bake (Optimized) |" >> $GITHUB_STEP_SUMMARY
        echo "| ðŸŒ Live URL | https://dive.docker-senpai.dev |" >> $GITHUB_STEP_SUMMARY
