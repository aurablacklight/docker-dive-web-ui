name: ðŸš€ CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  EC2_INSTANCE_TAG: dive-inspector-server

jobs:
  # =============================================================================
  # CI: BUILD, TEST, AND PUSH IMAGES
  # =============================================================================
  ci:
    name: ðŸ”¨ Build, Test & Push
    runs-on: ubuntu-latest
    
    outputs:
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
      backend-image: ${{ steps.meta.outputs.backend-tag }}
      frontend-image: ${{ steps.meta.outputs.frontend-tag }}
      
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
      
    - name: ðŸ” Detect changes
      id: changes
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
        else
          echo "should-deploy=false" >> $GITHUB_OUTPUT
        fi
        
    - name: ï¿½ Setup JFrog CLI
      uses: jfrog/setup-jfrog-cli@v4
      env:
        JF_URL: ${{ vars.JF_URL }}
        JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
        
    - name: ðŸ“ Extract metadata
      id: meta
      run: |
        echo "backend-tag=aurablacklight.jfrog.io/dive-docker/dive-inspector-backend:${{ github.run_number }}" >> $GITHUB_OUTPUT
        echo "frontend-tag=aurablacklight.jfrog.io/dive-docker/dive-inspector-frontend:${{ github.run_number }}" >> $GITHUB_OUTPUT
        
    - name: ðŸ’¾ Cache backend npm dependencies
      uses: actions/cache@v4
      with:
        path: backend/node_modules
        key: ${{ runner.os }}-backend-npm-${{ hashFiles('backend/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-backend-npm-
          
    - name: ðŸ’¾ Cache frontend npm dependencies
      uses: actions/cache@v4
      with:
        path: frontend/node_modules
        key: ${{ runner.os }}-frontend-npm-${{ hashFiles('frontend/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-frontend-npm-
          
    - name: ðŸ—ï¸ Build and push backend
      env:
        BACKEND_IMAGE: ${{ steps.meta.outputs.backend-tag }}
      run: |
        cd backend
        jf docker build -t $BACKEND_IMAGE .
        jf docker push $BACKEND_IMAGE
        
    - name: ðŸ—ï¸ Build and push frontend
      env:
        FRONTEND_IMAGE: ${{ steps.meta.outputs.frontend-tag }}
      run: |
        cd frontend
        jf docker build -t $FRONTEND_IMAGE -f Dockerfile.prod .
        jf docker push $FRONTEND_IMAGE
        
    - name: ðŸ§ª Run backend tests
      run: |
        docker run --rm \
          -v /var/run/docker.sock:/var/run/docker.sock \
          ${{ steps.meta.outputs.backend-tag }} \
          npm test
          
    - name: ðŸ“Š Publish Build info With JFrog CLI
      env:
        JFROG_CLI_BUILD_NAME: dive-inspector-build
        JFROG_CLI_BUILD_NUMBER: ${{ github.run_number }}
      run: |
        # Collect environment variables for the build
        jf rt build-collect-env
        # Collect VCS details from git and add them to the build
        jf rt build-add-git
        # Publish build info
        jf rt build-publish
          
    - name: ðŸ“Š Build performance report
      run: |
        echo "## ðŸš€ Build Performance" >> $GITHUB_STEP_SUMMARY
        echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Build Method | JFrog CLI + npm cache |" >> $GITHUB_STEP_SUMMARY
        echo "| NPM Cache | âœ… Enabled |" >> $GITHUB_STEP_SUMMARY
        echo "| Registry | JFrog Artifactory |" >> $GITHUB_STEP_SUMMARY
        echo "| Build Number | ${{ github.run_number }} |" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # CD: DEPLOY TO EC2
  # =============================================================================
  cd:
    name: ðŸš€ Deploy to EC2
    runs-on: ubuntu-latest
    needs: ci
    if: needs.ci.outputs.should-deploy == 'true'
    
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
      
    - name: ðŸ”§ Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_CICD_GITHUB_ACTIONS_USERID }}
        aws-secret-access-key: ${{ secrets.AWS_CICD_GITHUB_ACTIONS_ACCESSKEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: ðŸ” Get EC2 instance ID
      id: instance
      run: |
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${{ env.EC2_INSTANCE_TAG }}" \
                    "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].InstanceId" \
          --output text)
        
        if [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ]; then
          echo "âŒ No running EC2 instance found with tag: ${{ env.EC2_INSTANCE_TAG }}"
          exit 1
        fi
        
        echo "instance-id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "âœ… Found EC2 instance: $INSTANCE_ID"
        
    - name: ðŸš€ Deploy via SSM
      run: |
        echo "ðŸš€ Executing deployment on EC2 instance..."
        
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ steps.instance.outputs.instance-id }}" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "set -e",
            "echo \"ðŸš€ Starting deployment on $(date)\"", 
            "cd /opt/dive-inspector",
            "CURRENT_COMMIT=$(git rev-parse HEAD)",
            "echo \"ðŸ“ Current commit: $CURRENT_COMMIT\"",
            "git fetch origin",
            "git reset --hard origin/main", 
            "NEW_COMMIT=$(git rev-parse HEAD)",
            "echo \"ðŸ“ New commit: $NEW_COMMIT\"",
            "if [ \"$CURRENT_COMMIT\" = \"$NEW_COMMIT\" ]; then echo \"â„¹ï¸ No changes detected\"; exit 0; fi",
            "echo \"ðŸ”‘ Logging into JFrog...\"",
            "echo ${{ secrets.JF_ACCESS_TOKEN }} | docker login aurablacklight.jfrog.io -u ${{ github.actor }} --password-stdin",
            "echo \"ðŸ“ Updating image tags...\"",
            "sed -i \"s|dive-inspector-backend:latest|${{ needs.ci.outputs.backend-image }}|g\" docker-compose.yml",
            "sed -i \"s|dive-inspector-frontend:latest|${{ needs.ci.outputs.frontend-image }}|g\" docker-compose.yml",
            "echo \"ðŸ¥ Health check...\"",
            "curl -f http://localhost:3000/api/health || echo \"âš ï¸ Service unhealthy\"",
            "echo \"ðŸ“¦ Pulling images...\"", 
            "docker compose pull",
            "echo \"ðŸ”„ Restarting...\"",
            "docker compose up -d",
            "sleep 10",
            "echo \"ðŸ¥ Post-deployment check...\"",
            "for i in {1..30}; do if curl -f http://localhost:3000/api/health >/dev/null 2>&1; then echo \"âœ… Healthy!\"; break; fi; sleep 2; done",
            "echo \"ðŸŽ‰ Deployment complete!\"",
            "docker compose ps"
          ]' \
          --output text \
          --query "Command.CommandId")
        
        echo "âœ… Deployment command sent: $COMMAND_ID"
        
        # Wait for command completion
        echo "â³ Waiting for deployment to complete..."
        
        for i in {1..60}; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.instance.outputs.instance-id }}" \
            --query "Status" \
            --output text 2>/dev/null || echo "InProgress")
            
          echo "ðŸ“Š Status: $STATUS"
          
          if [ "$STATUS" = "Success" ]; then
            echo "âœ… Deployment completed successfully!"
            break
          elif [ "$STATUS" = "Failed" ]; then
            echo "âŒ Deployment failed!"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ steps.instance.outputs.instance-id }}" \
              --query "StandardErrorContent" \
              --output text
            exit 1
          elif [ $i -eq 60 ]; then
            echo "âŒ Deployment timed out after 10 minutes"
            exit 1
          fi
          
          sleep 10
        done
        
        # Get deployment output
        echo "ðŸ“‹ Deployment output:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ steps.instance.outputs.instance-id }}" \
          --query "StandardOutputContent" \
          --output text
          
    - name: ðŸ¥ Final health check
      run: |
        echo "ðŸ” Final health check against public endpoint..."
        
        # Check production endpoint through Cloudflare
        if curl -f -k "https://dive.docker-senpai.dev/api/health" > /dev/null 2>&1; then
          echo "âœ… Production health check passed!"
        else
          echo "âš ï¸ Production health check failed (might be DNS propagation)"
        fi
        
    - name: ðŸ“Š Deployment summary
      run: |
        echo "## ðŸŽ‰ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Item | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| ðŸ—ï¸ Build | âœ… Success |" >> $GITHUB_STEP_SUMMARY
        echo "| ðŸ§ª Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
        echo "| ðŸš€ Deployment | âœ… Success |" >> $GITHUB_STEP_SUMMARY
        echo "| ðŸ¥ Health Check | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
        echo "| ðŸ“¦ Registry | JFrog Artifactory |" >> $GITHUB_STEP_SUMMARY
        echo "| ðŸŒ Live URL | https://dive.docker-senpai.dev |" >> $GITHUB_STEP_SUMMARY
